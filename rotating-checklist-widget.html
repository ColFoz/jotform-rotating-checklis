<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Rotating Housekeeping Checklist</title>
    <script>
        // Pre-check for JotForm context before loading their script
        window.isJotFormEmbed = window.parent !== window;
    </script>
    <script src="//js.jotform.com/JotFormCustomWidget.min.js" onerror="console.log('JotForm script not loaded - standalone mode')"></script>
    <style>
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            padding: 16px;
            background: #fafafa;
            color: #333;
        }

        .widget-container {
            max-width: 600px;
        }

        .property-selector {
            margin-bottom: 20px;
        }

        .property-selector label {
            display: block;
            font-weight: 600;
            margin-bottom: 8px;
            color: #444;
        }

        .property-selector select {
            width: 100%;
            padding: 12px;
            font-size: 16px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
            cursor: pointer;
        }

        .property-selector select:focus {
            outline: none;
            border-color: #4a90d9;
        }

        .loading {
            text-align: center;
            padding: 40px;
            color: #666;
        }

        .loading-spinner {
            display: inline-block;
            width: 24px;
            height: 24px;
            border: 3px solid #eee;
            border-top-color: #4a90d9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .checklist-section {
            margin-bottom: 24px;
        }

        .section-header {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 12px 16px;
            background: #e8f4f8;
            border-radius: 8px 8px 0 0;
            font-weight: 600;
            color: #2c5282;
        }

        .section-icon {
            font-size: 18px;
        }

        .checklist-items {
            background: white;
            border: 1px solid #e2e8f0;
            border-top: none;
            border-radius: 0 0 8px 8px;
        }

        .checklist-item {
            display: flex;
            align-items: flex-start;
            padding: 14px 16px;
            border-bottom: 1px solid #f0f0f0;
            transition: background 0.15s;
        }

        .checklist-item:last-child {
            border-bottom: none;
        }

        .checklist-item:hover {
            background: #f8fafc;
        }

        .checklist-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            margin-top: 2px;
            cursor: pointer;
            accent-color: #4a90d9;
        }

        .item-content {
            flex: 1;
        }

        .item-name {
            font-weight: 500;
            color: #333;
            margin-bottom: 4px;
        }

        .item-meta {
            font-size: 13px;
            color: #888;
        }

        .item-instructions {
            font-size: 13px;
            color: #666;
            margin-top: 6px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 4px;
            display: none;
        }

        .checklist-item.expanded .item-instructions {
            display: block;
        }

        .expand-btn {
            background: none;
            border: none;
            color: #4a90d9;
            font-size: 12px;
            cursor: pointer;
            padding: 4px 8px;
            margin-top: 4px;
        }

        .expand-btn:hover {
            text-decoration: underline;
        }

        .no-items {
            text-align: center;
            padding: 40px 20px;
            background: #f0fff4;
            border-radius: 8px;
            color: #276749;
        }

        .no-items-icon {
            font-size: 48px;
            margin-bottom: 12px;
        }

        .overdue-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #fed7d7;
            color: #c53030;
            font-size: 11px;
            font-weight: 600;
            border-radius: 4px;
            margin-left: 8px;
        }

        .due-soon-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #fefcbf;
            color: #975a16;
            font-size: 11px;
            font-weight: 600;
            border-radius: 4px;
            margin-left: 8px;
        }

        .error-message {
            background: #fed7d7;
            color: #c53030;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
        }

        .summary-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: #edf2f7;
            border-radius: 8px;
            margin-bottom: 16px;
            font-size: 14px;
        }

        .summary-count {
            font-weight: 600;
            color: #4a5568;
        }

        .summary-count .number {
            color: #4a90d9;
            font-size: 18px;
        }
    </style>
</head>
<body>
    <div class="widget-container" id="widget">
        <div class="loading" id="initialLoading">
            <div class="loading-spinner"></div>
            <div>Loading properties...</div>
        </div>
    </div>

    <!-- Test controls for standalone mode -->
    <div id="testControls" style="display: none; margin-top: 20px; padding: 16px; background: #fffbeb; border: 1px solid #f59e0b; border-radius: 8px;">
        <div style="font-weight: 600; color: #92400e; margin-bottom: 8px;">Standalone Test Mode</div>
        <div style="font-size: 13px; color: #78350f; margin-bottom: 12px;">
            This widget is running outside JotForm. Use the button below to simulate form submission.
        </div>
        <button onclick="simulateSubmit()" style="background: #4a90d9; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px;">
            Test Submit
        </button>
        <button onclick="clearApiKey()" style="background: #dc2626; color: white; border: none; padding: 10px 20px; border-radius: 6px; cursor: pointer; font-size: 14px; margin-left: 8px;">
            Clear API Key
        </button>
    </div>

    <script>
        // Detect if we're inside JotForm or standalone
        const isJotFormContext = typeof JFCustomWidget !== 'undefined';

        // Mock JFCustomWidget for standalone testing
        if (!isJotFormContext) {
            window.JFCustomWidget = {
                subscribe: function(event, callback) {
                    if (event === 'ready') {
                        // Auto-trigger ready event after a short delay
                        setTimeout(() => callback({ value: null }), 100);
                    }
                    // Store submit callback for later
                    if (event === 'submit') {
                        this._submitCallback = callback;
                    }
                },
                getWidgetSetting: function(name) {
                    // For standalone testing, get from URL params or prompt
                    const urlParams = new URLSearchParams(window.location.search);
                    if (urlParams.has(name)) {
                        return urlParams.get(name);
                    }
                    // Check localStorage for saved API key
                    if (name === 'airtableApiKey') {
                        let key = localStorage.getItem('airtable_api_key');
                        if (!key) {
                            key = prompt('Enter your Airtable API Key (starts with pat...):');
                            if (key) localStorage.setItem('airtable_api_key', key);
                        }
                        return key;
                    }
                    return null;
                },
                sendData: function(data) {
                    console.log('Widget data:', data);
                },
                sendSubmit: function(data) {
                    console.log('Widget submit:', data);
                    alert('Form submitted! Check console for data.');
                },
                requestFrameResize: function(data) {
                    console.log('Resize requested:', data);
                }
            };
            console.log('Running in standalone mode (outside JotForm)');
        }

        // Configuration - these come from JotForm widget settings
        let CONFIG = {
            airtableApiKey: '',
            baseId: 'app6guGAO369FvUar',
            listingsTableId: 'tblnmc2ODzG9qK7Mn',
            checklistItemsTableId: 'tbltKuitiWgzDe9R6',
            checklistLogTableId: 'tblYnYlo85WiNLJ3H'
        };

        // State
        let state = {
            properties: [],
            checklistItems: [],
            checklistLog: [],
            selectedPropertyId: null,
            selectedPropertyName: null,
            checkedItems: new Set()
        };

        // Category icons
        const categoryIcons = {
            'Appliances': 'ðŸ”Œ',
            'Safety & Security': 'ðŸ”',
            'Deep Clean': 'ðŸ§¹',
            'Maintenance': 'ðŸ”§',
            'Inventory': 'ðŸ“¦'
        };

        // Airtable API helper
        async function airtableFetch(tableId, params = {}) {
            const url = new URL(`https://api.airtable.com/v0/${CONFIG.baseId}/${tableId}`);
            Object.keys(params).forEach(key => url.searchParams.append(key, params[key]));

            const response = await fetch(url, {
                headers: {
                    'Authorization': `Bearer ${CONFIG.airtableApiKey}`,
                    'Content-Type': 'application/json'
                }
            });

            if (!response.ok) {
                throw new Error(`Airtable error: ${response.status}`);
            }

            return response.json();
        }

        async function airtableCreate(tableId, fields) {
            const response = await fetch(`https://api.airtable.com/v0/${CONFIG.baseId}/${tableId}`, {
                method: 'POST',
                headers: {
                    'Authorization': `Bearer ${CONFIG.airtableApiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ fields })
            });

            if (!response.ok) {
                throw new Error(`Airtable create error: ${response.status}`);
            }

            return response.json();
        }

        async function airtableUpdate(tableId, recordId, fields) {
            const response = await fetch(`https://api.airtable.com/v0/${CONFIG.baseId}/${tableId}/${recordId}`, {
                method: 'PATCH',
                headers: {
                    'Authorization': `Bearer ${CONFIG.airtableApiKey}`,
                    'Content-Type': 'application/json'
                },
                body: JSON.stringify({ fields })
            });

            if (!response.ok) {
                throw new Error(`Airtable update error: ${response.status}`);
            }

            return response.json();
        }

        // Load properties from Airtable
        async function loadProperties() {
            const data = await airtableFetch(CONFIG.listingsTableId, {
                'fields[]': 'Name',
                'sort[0][field]': 'Name',
                'sort[0][direction]': 'asc'
            });
            state.properties = data.records.map(r => ({
                id: r.id,
                name: r.fields['Name']
            })).filter(p => p.name);
        }

        // Load checklist items
        async function loadChecklistItems() {
            const data = await airtableFetch(CONFIG.checklistItemsTableId, {
                'filterByFormula': '{Active}=TRUE()'
            });
            state.checklistItems = data.records.map(r => ({
                id: r.id,
                name: r.fields['Item Name'],
                frequencyDays: r.fields['Frequency Days'] || 30,
                category: r.fields['Category'] || 'General',
                instructions: r.fields['Instructions'] || ''
            }));
        }

        // Load checklist log for a property
        async function loadChecklistLog(propertyId) {
            const formula = `FIND("${propertyId}", ARRAYJOIN({Property}))`;
            const data = await airtableFetch(CONFIG.checklistLogTableId, {
                'filterByFormula': formula
            });
            state.checklistLog = data.records.map(r => ({
                id: r.id,
                propertyIds: r.fields['Property'] || [],
                checklistItemIds: r.fields['Checklist Item'] || [],
                lastChecked: r.fields['Last Checked'],
                checkedBy: r.fields['Checked By']
            }));
        }

        // Calculate days since last check
        function getDaysSinceCheck(checklistItemId) {
            const logEntry = state.checklistLog.find(log =>
                log.checklistItemIds.includes(checklistItemId)
            );

            if (!logEntry || !logEntry.lastChecked) {
                return Infinity; // Never checked
            }

            const lastDate = new Date(logEntry.lastChecked);
            const today = new Date();
            const diffTime = today - lastDate;
            return Math.floor(diffTime / (1000 * 60 * 60 * 24));
        }

        // Get items due for checking
        function getDueItems() {
            return state.checklistItems.map(item => {
                const daysSince = getDaysSinceCheck(item.id);
                const daysOverdue = daysSince - item.frequencyDays;
                const isDue = daysSince >= item.frequencyDays;
                const isDueSoon = daysSince >= item.frequencyDays * 0.8;

                return {
                    ...item,
                    daysSince,
                    daysOverdue,
                    isDue,
                    isDueSoon,
                    neverChecked: daysSince === Infinity
                };
            }).filter(item => item.isDue || item.isDueSoon || item.neverChecked);
        }

        // Render property selector
        function renderPropertySelector() {
            const widget = document.getElementById('widget');

            let html = `
                <div class="property-selector">
                    <label for="propertySelect">Select Property</label>
                    <select id="propertySelect" onchange="onPropertyChange(this.value)">
                        <option value="">-- Choose a property --</option>
                        ${state.properties.map(p => `
                            <option value="${p.id}" data-name="${p.name}">${p.name}</option>
                        `).join('')}
                    </select>
                </div>
                <div id="checklistContainer"></div>
            `;

            widget.innerHTML = html;
        }

        // Render checklist
        function renderChecklist() {
            const container = document.getElementById('checklistContainer');
            const dueItems = getDueItems();

            if (dueItems.length === 0) {
                container.innerHTML = `
                    <div class="no-items">
                        <div class="no-items-icon">âœ…</div>
                        <div><strong>All caught up!</strong></div>
                        <div style="margin-top: 8px; font-size: 14px;">No periodic checks due for this property.</div>
                    </div>
                `;
                return;
            }

            // Group by category
            const byCategory = {};
            dueItems.forEach(item => {
                if (!byCategory[item.category]) {
                    byCategory[item.category] = [];
                }
                byCategory[item.category].push(item);
            });

            let html = `
                <div class="summary-bar">
                    <span class="summary-count"><span class="number">${dueItems.length}</span> items due</span>
                    <span>Check completed items below</span>
                </div>
            `;

            Object.keys(byCategory).sort().forEach(category => {
                const items = byCategory[category];
                const icon = categoryIcons[category] || 'ðŸ“‹';

                html += `
                    <div class="checklist-section">
                        <div class="section-header">
                            <span class="section-icon">${icon}</span>
                            <span>${category}</span>
                        </div>
                        <div class="checklist-items">
                            ${items.map(item => {
                                const badge = item.neverChecked
                                    ? '<span class="overdue-badge">Never checked</span>'
                                    : item.daysOverdue > 0
                                        ? `<span class="overdue-badge">${item.daysOverdue} days overdue</span>`
                                        : '<span class="due-soon-badge">Due soon</span>';

                                return `
                                    <div class="checklist-item" id="item-${item.id}">
                                        <input type="checkbox"
                                            id="check-${item.id}"
                                            data-item-id="${item.id}"
                                            data-item-name="${item.name}"
                                            onchange="onItemCheck('${item.id}', this.checked)">
                                        <div class="item-content">
                                            <div class="item-name">
                                                ${item.name}
                                                ${badge}
                                            </div>
                                            <div class="item-meta">
                                                Every ${item.frequencyDays} days
                                                ${!item.neverChecked ? ` â€¢ Last checked ${item.daysSince} days ago` : ''}
                                            </div>
                                            ${item.instructions ? `
                                                <button class="expand-btn" onclick="toggleInstructions('${item.id}')">
                                                    Show instructions
                                                </button>
                                                <div class="item-instructions">${item.instructions}</div>
                                            ` : ''}
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>
                `;
            });

            container.innerHTML = html;
        }

        // Toggle instructions visibility
        function toggleInstructions(itemId) {
            const itemEl = document.getElementById(`item-${itemId}`);
            const btn = itemEl.querySelector('.expand-btn');
            itemEl.classList.toggle('expanded');
            btn.textContent = itemEl.classList.contains('expanded') ? 'Hide instructions' : 'Show instructions';
        }

        // Handle property change
        async function onPropertyChange(propertyId) {
            if (!propertyId) {
                document.getElementById('checklistContainer').innerHTML = '';
                state.selectedPropertyId = null;
                state.selectedPropertyName = null;
                state.checkedItems.clear();
                sendDataToJotForm();
                return;
            }

            const container = document.getElementById('checklistContainer');
            container.innerHTML = '<div class="loading"><div class="loading-spinner"></div><div>Loading checklist...</div></div>';

            state.selectedPropertyId = propertyId;
            state.selectedPropertyName = document.querySelector(`#propertySelect option[value="${propertyId}"]`).dataset.name;
            state.checkedItems.clear();

            try {
                await loadChecklistLog(propertyId);
                renderChecklist();
                sendDataToJotForm();
                resizeWidget();
            } catch (error) {
                console.error('Error loading checklist:', error);
                container.innerHTML = `<div class="error-message">Error loading checklist: ${error.message}</div>`;
            }
        }

        // Handle item check
        function onItemCheck(itemId, checked) {
            if (checked) {
                state.checkedItems.add(itemId);
            } else {
                state.checkedItems.delete(itemId);
            }
            sendDataToJotForm();
        }

        // Send data to JotForm
        function sendDataToJotForm() {
            const checkedItemNames = Array.from(state.checkedItems).map(id => {
                const item = state.checklistItems.find(i => i.id === id);
                return item ? item.name : id;
            });

            const value = JSON.stringify({
                property: state.selectedPropertyName,
                propertyId: state.selectedPropertyId,
                checkedItems: checkedItemNames,
                checkedItemIds: Array.from(state.checkedItems),
                checkedAt: new Date().toISOString()
            });

            JFCustomWidget.sendData({ value });
        }

        // Resize widget to fit content
        function resizeWidget() {
            setTimeout(() => {
                const height = document.body.scrollHeight + 40;
                JFCustomWidget.requestFrameResize({ height });
            }, 100);
        }

        // Update Airtable when form is submitted
        async function updateAirtable() {
            if (!state.selectedPropertyId || state.checkedItems.size === 0) {
                return { success: true, message: 'No items to update' };
            }

            const today = new Date().toISOString().split('T')[0];
            const results = [];

            for (const itemId of state.checkedItems) {
                try {
                    // Check if log entry exists
                    const existingLog = state.checklistLog.find(log =>
                        log.checklistItemIds.includes(itemId) &&
                        log.propertyIds.includes(state.selectedPropertyId)
                    );

                    if (existingLog) {
                        // Update existing
                        await airtableUpdate(CONFIG.checklistLogTableId, existingLog.id, {
                            'Last Checked': today,
                            'Checked By': 'JotForm Widget'
                        });
                    } else {
                        // Create new
                        const item = state.checklistItems.find(i => i.id === itemId);
                        await airtableCreate(CONFIG.checklistLogTableId, {
                            'Log Entry': `${state.selectedPropertyName} - ${item?.name}`,
                            'Property': [state.selectedPropertyId],
                            'Checklist Item': [itemId],
                            'Last Checked': today,
                            'Checked By': 'JotForm Widget'
                        });
                    }
                    results.push({ itemId, success: true });
                } catch (error) {
                    console.error(`Error updating item ${itemId}:`, error);
                    results.push({ itemId, success: false, error: error.message });
                }
            }

            return { success: true, results };
        }

        // Initialize widget
        async function init() {
            try {
                // Get API key from URL params first (for iframe embed), then widget settings, then localStorage
                const urlParams = new URLSearchParams(window.location.search);
                CONFIG.airtableApiKey = urlParams.get('airtableApiKey')
                    || JFCustomWidget.getWidgetSetting('airtableApiKey')
                    || localStorage.getItem('airtable_api_key')
                    || '';

                // Override base ID if provided
                const customBaseId = urlParams.get('baseId') || JFCustomWidget.getWidgetSetting('baseId');
                if (customBaseId) CONFIG.baseId = customBaseId;

                if (!CONFIG.airtableApiKey) {
                    document.getElementById('widget').innerHTML = `
                        <div class="error-message">
                            <strong>Configuration Required</strong><br>
                            Please add your Airtable API key in the widget settings.
                        </div>
                    `;
                    return;
                }

                // Load initial data
                await Promise.all([
                    loadProperties(),
                    loadChecklistItems()
                ]);

                renderPropertySelector();
                resizeWidget();

            } catch (error) {
                console.error('Initialization error:', error);
                document.getElementById('widget').innerHTML = `
                    <div class="error-message">
                        <strong>Error loading widget</strong><br>
                        ${error.message}
                    </div>
                `;
            }
        }

        // JotForm widget lifecycle
        JFCustomWidget.subscribe("ready", function(data) {
            console.log('Widget ready, initializing...');

            // Restore previous value if editing submission
            if (data.value) {
                try {
                    const savedData = JSON.parse(data.value);
                    // Could restore state here if needed
                } catch (e) {}
            }

            init();
        });

        // Auto-init if API key is in URL (for iframe embed that doesn't trigger ready event)
        const urlParams = new URLSearchParams(window.location.search);
        if (urlParams.get('airtableApiKey')) {
            console.log('API key found in URL, auto-initializing...');
            // Wait a moment for DOM to be ready
            if (document.readyState === 'loading') {
                document.addEventListener('DOMContentLoaded', init);
            } else {
                setTimeout(init, 100);
            }
        }

        JFCustomWidget.subscribe("submit", async function() {
            // Update Airtable with checked items
            try {
                await updateAirtable();
            } catch (error) {
                console.error('Error updating Airtable on submit:', error);
            }

            // Send final data to JotForm
            const checkedItemNames = Array.from(state.checkedItems).map(id => {
                const item = state.checklistItems.find(i => i.id === id);
                return item ? item.name : id;
            });

            JFCustomWidget.sendSubmit({
                valid: true,
                value: JSON.stringify({
                    property: state.selectedPropertyName,
                    propertyId: state.selectedPropertyId,
                    completedItems: checkedItemNames,
                    completedAt: new Date().toISOString()
                })
            });
        });

        // Make functions available globally for inline handlers
        window.onPropertyChange = onPropertyChange;
        window.onItemCheck = onItemCheck;
        window.toggleInstructions = toggleInstructions;

        // Test mode functions
        function simulateSubmit() {
            if (JFCustomWidget._submitCallback) {
                JFCustomWidget._submitCallback();
            } else {
                // Manual submit logic
                const checkedItemNames = Array.from(state.checkedItems).map(id => {
                    const item = state.checklistItems.find(i => i.id === id);
                    return item ? item.name : id;
                });

                console.log('Simulated submit:', {
                    property: state.selectedPropertyName,
                    propertyId: state.selectedPropertyId,
                    completedItems: checkedItemNames,
                    completedAt: new Date().toISOString()
                });

                // Still update Airtable
                updateAirtable().then(result => {
                    console.log('Airtable update result:', result);
                    alert(`Submitted! ${state.checkedItems.size} items marked as checked.\nCheck console for details.`);
                }).catch(err => {
                    alert('Error updating Airtable: ' + err.message);
                });
            }
        }

        function clearApiKey() {
            localStorage.removeItem('airtable_api_key');
            alert('API key cleared. Reload the page to enter a new one.');
            location.reload();
        }

        window.simulateSubmit = simulateSubmit;
        window.clearApiKey = clearApiKey;

        // Show test controls if in standalone mode (after DOM ready)
        document.addEventListener('DOMContentLoaded', function() {
            if (!isJotFormContext) {
                const testControls = document.getElementById('testControls');
                if (testControls) testControls.style.display = 'block';
            }
        });

        // Also check immediately in case DOM already loaded
        if (document.readyState !== 'loading' && !isJotFormContext) {
            const testControls = document.getElementById('testControls');
            if (testControls) testControls.style.display = 'block';
        }
    </script>
</body>
</html>